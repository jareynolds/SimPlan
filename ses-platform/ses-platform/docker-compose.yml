version: '3.8'

services:
  # PostgreSQL Database
  postgres:
    image: postgres:14-alpine
    container_name: ses-postgres
    environment:
      POSTGRES_DB: ses_platform
      POSTGRES_USER: ses_user
      POSTGRES_PASSWORD: ses_password
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/schema.sql:/docker-entrypoint-initdb.d/01-schema.sql:ro
    ports:
      - "5432:5432"
    networks:
      - ses-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ses_user -d ses_platform"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Go Backend API
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: ses-backend
    environment:
      # Database Configuration
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: ses_platform
      DB_USER: ses_user
      DB_PASSWORD: ses_password
      DB_SSLMODE: disable
      
      # Server Configuration
      SERVER_PORT: 8080
      GIN_MODE: release
      
      # Application Configuration
      LOG_LEVEL: info
      CORS_ALLOWED_ORIGINS: "*"
    ports:
      - "8080:8080"
    networks:
      - ses-network
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped
    volumes:
      - backend_logs:/var/log/ses
      - uploads:/var/uploads

  # React Frontend
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        REACT_APP_API_URL: http://localhost:8080/api/v1
    container_name: ses-frontend
    environment:
      REACT_APP_API_URL: http://backend:8080/api/v1
      NODE_ENV: production
    ports:
      - "3000:80"
    networks:
      - ses-network
    depends_on:
      - backend
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:80"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # Redis for caching and session management (optional)
  redis:
    image: redis:7-alpine
    container_name: ses-redis
    command: redis-server --appendonly yes
    ports:
      - "6379:6379"
    networks:
      - ses-network
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Prometheus for metrics collection (optional)
  prometheus:
    image: prom/prometheus:latest
    container_name: ses-prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
    ports:
      - "9090:9090"
    networks:
      - ses-network
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus
    restart: unless-stopped

  # Grafana for visualization (optional)
  grafana:
    image: grafana/grafana:latest
    container_name: ses-grafana
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
      - GF_USERS_ALLOW_SIGN_UP=false
    ports:
      - "3001:3000"
    networks:
      - ses-network
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards:ro
      - ./monitoring/grafana/datasources:/etc/grafana/provisioning/datasources:ro
    depends_on:
      - prometheus
    restart: unless-stopped

networks:
  ses-network:
    driver: bridge
    name: ses-network

volumes:
  postgres_data:
    name: ses-postgres-data
  redis_data:
    name: ses-redis-data
  prometheus_data:
    name: ses-prometheus-data
  grafana_data:
    name: ses-grafana-data
  backend_logs:
    name: ses-backend-logs
  uploads:
    name: ses-uploads

# ============================================
# Additional Configuration Files Needed
# ============================================

# ./backend/Dockerfile
# ---------------------
# FROM golang:1.21-alpine AS builder
# WORKDIR /app
# COPY go.mod go.sum ./
# RUN go mod download
# COPY . .
# RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .
# 
# FROM alpine:latest
# RUN apk --no-cache add ca-certificates wget
# WORKDIR /root/
# COPY --from=builder /app/main .
# EXPOSE 8080
# CMD ["./main"]

# ./frontend/Dockerfile
# ----------------------
# FROM node:18-alpine AS builder
# WORKDIR /app
# COPY package*.json ./
# RUN npm ci
# COPY . .
# ARG REACT_APP_API_URL
# ENV REACT_APP_API_URL=$REACT_APP_API_URL
# RUN npm run build
# 
# FROM nginx:alpine
# COPY --from=builder /app/build /usr/share/nginx/html
# COPY nginx.conf /etc/nginx/conf.d/default.conf
# EXPOSE 80
# CMD ["nginx", "-g", "daemon off;"]

# ./frontend/nginx.conf
# ----------------------
# server {
#     listen 80;
#     server_name localhost;
#     root /usr/share/nginx/html;
#     index index.html;
# 
#     location / {
#         try_files $uri $uri/ /index.html;
#     }
# 
#     location /api/ {
#         proxy_pass http://backend:8080/api/;
#         proxy_http_version 1.1;
#         proxy_set_header Upgrade $http_upgrade;
#         proxy_set_header Connection 'upgrade';
#         proxy_set_header Host $host;
#         proxy_cache_bypass $http_upgrade;
#     }
# }

# ./monitoring/prometheus.yml
# ---------------------------
# global:
#   scrape_interval: 15s
#   evaluation_interval: 15s
# 
# scrape_configs:
#   - job_name: 'ses-backend'
#     static_configs:
#       - targets: ['backend:8080']
#     metrics_path: '/metrics'
# 
#   - job_name: 'postgres'
#     static_configs:
#       - targets: ['postgres:5432']
# 
#   - job_name: 'prometheus'
#     static_configs:
#       - targets: ['localhost:9090']

# ============================================
# Usage Instructions
# ============================================

# Quick Start:
# 1. Ensure Docker and Docker Compose are installed
# 2. Clone the repository
# 3. Create required Dockerfiles (see comments above)
# 4. Run: docker-compose up -d
# 5. Access:
#    - Frontend: http://localhost:3000
#    - Backend API: http://localhost:8080
#    - Prometheus: http://localhost:9090
#    - Grafana: http://localhost:3001

# Management Commands:
# Start all services:        docker-compose up -d
# Stop all services:         docker-compose down
# View logs:                 docker-compose logs -f [service_name]
# Restart service:           docker-compose restart [service_name]
# Rebuild service:           docker-compose up -d --build [service_name]
# Check service health:      docker-compose ps
# Execute command in container: docker-compose exec [service] [command]

# Database Management:
# Access PostgreSQL:         docker-compose exec postgres psql -U ses_user -d ses_platform
# Backup database:           docker-compose exec postgres pg_dump -U ses_user ses_platform > backup.sql
# Restore database:          docker-compose exec -T postgres psql -U ses_user ses_platform < backup.sql

# Monitoring:
# View Prometheus targets:   http://localhost:9090/targets
# Access Grafana:            http://localhost:3001 (admin/admin)

# Cleanup:
# Stop and remove containers: docker-compose down
# Remove volumes:             docker-compose down -v
# Remove everything:          docker-compose down -v --rmi all

# Production Deployment:
# For production, update the following:
# 1. Change all default passwords
# 2. Use environment-specific .env files
# 3. Configure proper SSL/TLS certificates
# 4. Set up log rotation and monitoring alerts
# 5. Configure backup strategies
# 6. Implement proper secrets management
# 7. Use production-grade reverse proxy (Traefik/Nginx)
# 8. Configure resource limits and constraints
